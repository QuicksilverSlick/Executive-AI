<!DOCTYPE html><html lang=en><head><meta charset=UTF-8><meta content="width=device-width,initial-scale=1" name=viewport><title>Session Persistence Test</title><style>body{font-family:Arial,sans-serif;max-width:800px;margin:0 auto;padding:20px;background:#f5f5f5}.test-section{background:#fff;padding:20px;margin:10px 0;border-radius:8px;box-shadow:0 2px 4px rgba(0,0,0,.1)}.success{color:#28a745}.error{color:#dc3545}.warning{color:#ffc107}button{background:#007bff;color:#fff;border:none;padding:10px 20px;border-radius:4px;cursor:pointer;margin:5px}button:hover{background:#0056b3}.log{background:#f8f9fa;border:1px solid #dee2e6;padding:10px;margin:10px 0;border-radius:4px;font-family:monospace;white-space:pre-wrap;max-height:200px;overflow-y:auto}</style></head><body><h1>🔧 Session Persistence Fix Validation</h1><p>This page tests the critical fixes applied to the WebRTC Voice Assistant session persistence system.</p><div class=test-section><h2>🧪 Module Loading Test</h2><p>Testing ES6 imports vs require() statements</p><button onclick=testModuleLoading()>Test Module Loading</button><div class=log id=module-results></div></div><div class=test-section><h2>🗄️ IndexedDB Test</h2><p>Testing IndexedDB transaction management fixes</p><button onclick=testIndexedDB()>Test IndexedDB</button><div class=log id=indexeddb-results></div></div><div class=test-section><h2>🔐 Encryption Test</h2><p>Testing Web Crypto API functionality</p><button onclick=testEncryption()>Test Encryption</button><div class=log id=encryption-results></div></div><div class=test-section><h2>💾 Session Storage Test</h2><p>Testing session persistence functionality</p><button onclick=testSessionPersistence()>Test Session Persistence</button><div class=log id=session-results></div></div><div class=test-section><h2>🔄 Cross-Page Persistence Test</h2><p>Testing session restoration across page reloads</p><button onclick=testCrossPagePersistence()>Save Test Session</button> <button onclick=window.location.reload()>Reload Page</button> <button onclick=restoreTestSession()>Restore Test Session</button><div class=log id=crosspage-results></div></div><script>let testLog={module:[],indexeddb:[],encryption:[],session:[],crosspage:[]};function updateLog(e,s,t="info"){const o=`[${(new Date).toISOString().split("T")[1].split(".")[0]}] ${t.toUpperCase()}: ${s}`;testLog[e].push(o);const a=document.getElementById(`${e}-results`);a&&(a.textContent=testLog[e].join("\n"),a.className=`log ${t}`)}async function testModuleLoading(){updateLog("module","Testing module loading...","info");try{let e=!1;try{require("non-existent-module")}catch(s){e=!0,updateLog("module",`✅ require() correctly throws error: ${s.message}`,"success")}e||updateLog("module","⚠️ require() unexpectedly available in browser","warning"),updateLog("module","✅ ES6 imports would work correctly","success"),updateLog("module","Module loading test completed successfully","success")}catch(e){updateLog("module",`❌ Module loading test failed: ${e.message}`,"error")}}async function testIndexedDB(){updateLog("indexeddb","Testing IndexedDB functionality...","info");try{if(!window.indexedDB)throw new Error("IndexedDB not supported");const e="VoiceAssistantSessions_Test",s=indexedDB.open(e,1);s.onupgradeneeded=e=>{const s=e.target.result;if(!s.objectStoreNames.contains("sessions")){s.createObjectStore("sessions",{keyPath:"sessionId"}).createIndex("lastActivity","lastActivity",{unique:!1}),updateLog("indexeddb","✅ Object store created successfully","success")}},s.onsuccess=async e=>{const s=e.target.result;updateLog("indexeddb","✅ Database opened successfully","success");try{const e=s.transaction(["sessions"],"readwrite"),t=e.objectStore("sessions"),o={sessionId:"test-"+Date.now(),messages:["test message"],connectionState:"connected",conversationState:"idle",startTime:Date.now(),lastActivity:Date.now(),metadata:{userAgent:navigator.userAgent,totalMessages:1,totalDuration:0}};t.put(o);e.oncomplete=()=>{updateLog("indexeddb","✅ Transaction completed successfully","success"),updateLog("indexeddb","IndexedDB transaction fix validated!","success")},e.onerror=()=>{updateLog("indexeddb",`❌ Transaction failed: ${e.error}`,"error")}}catch(e){updateLog("indexeddb",`❌ Transaction error: ${e.message}`,"error")}s.close()},s.onerror=()=>{updateLog("indexeddb",`❌ Failed to open database: ${s.error}`,"error")}}catch(e){updateLog("indexeddb",`❌ IndexedDB test failed: ${e.message}`,"error")}}async function testEncryption(){updateLog("encryption","Testing Web Crypto API...","info");try{if(!window.crypto||!window.crypto.subtle)throw new Error("Web Crypto API not supported");const e=await crypto.subtle.generateKey({name:"AES-GCM",length:256},!0,["encrypt","decrypt"]);updateLog("encryption","✅ Encryption key generated","success");const s="Test message for encryption",t=(new TextEncoder).encode(s),o=crypto.getRandomValues(new Uint8Array(12)),a=await crypto.subtle.encrypt({name:"AES-GCM",iv:o},e,t);updateLog("encryption","✅ Data encrypted successfully","success");const n=await crypto.subtle.decrypt({name:"AES-GCM",iv:o},e,a);(new TextDecoder).decode(n)===s?(updateLog("encryption","✅ Data decrypted successfully","success"),updateLog("encryption","Encryption test completed successfully","success")):updateLog("encryption","❌ Decrypted data does not match original","error")}catch(e){updateLog("encryption",`❌ Encryption test failed: ${e.message}`,"error")}}async function testSessionPersistence(){updateLog("session","Testing session persistence...","info");try{const e={sessionId:"test-session-"+Date.now(),shouldRestore:!0,lastActivity:Date.now(),pageLoadTime:Date.now()};sessionStorage.setItem("va_active_session_test",JSON.stringify(e)),updateLog("session","✅ Session data saved to sessionStorage","success");JSON.parse(sessionStorage.getItem("va_active_session_test")).sessionId===e.sessionId?updateLog("session","✅ Session data retrieved correctly","success"):updateLog("session","❌ Retrieved data does not match","error");const s={voicePersonality:"sage",isMinimized:!1,showTranscript:!0,volume:.8,theme:"auto",position:"bottom-right"};localStorage.setItem("voice_assistant_preferences_test",JSON.stringify(s)),updateLog("session","✅ Preferences saved to localStorage","success");JSON.parse(localStorage.getItem("voice_assistant_preferences_test")).voicePersonality===s.voicePersonality?(updateLog("session","✅ Preferences retrieved correctly","success"),updateLog("session","Session persistence test completed successfully","success")):updateLog("session","❌ Retrieved preferences do not match","error")}catch(e){updateLog("session",`❌ Session persistence test failed: ${e.message}`,"error")}}async function testCrossPagePersistence(){updateLog("crosspage","Saving test session for cross-page test...","info");const e={sessionId:"cross-page-test-"+Date.now(),messages:[{id:"msg-1",type:"user",content:"Hello, this is a test message",timestamp:(new Date).toISOString()},{id:"msg-2",type:"assistant",content:"Hello! This is a test response that should persist across page reloads.",timestamp:(new Date).toISOString()}],shouldRestore:!0,lastActivity:Date.now(),pageLoadTime:Date.now()};sessionStorage.setItem("va_active_session",JSON.stringify(e)),localStorage.setItem("va_test_session_backup",JSON.stringify(e)),updateLog("crosspage","✅ Test session saved","success"),updateLog("crosspage",`Session ID: ${e.sessionId}`,"info"),updateLog("crosspage",`Messages: ${e.messages.length}`,"info"),updateLog("crosspage",'Now reload the page and click "Restore Test Session"',"info")}async function restoreTestSession(){updateLog("crosspage","Attempting to restore test session...","info");try{let e=sessionStorage.getItem("va_active_session");if(e||(e=localStorage.getItem("va_test_session_backup"),updateLog("crosspage","⚠️ Using localStorage fallback","warning")),e){const s=JSON.parse(e);updateLog("crosspage","✅ Session data found!","success"),updateLog("crosspage",`Session ID: ${s.sessionId}`,"info"),updateLog("crosspage",`Messages: ${s.messages?s.messages.length:0}`,"info"),updateLog("crosspage",`Last Activity: ${new Date(s.lastActivity).toLocaleTimeString()}`,"info"),s.messages&&s.messages.length>0&&(updateLog("crosspage","✅ Cross-page persistence working!","success"),updateLog("crosspage",`First message: "${s.messages[0].content}"`,"info"))}else updateLog("crosspage","❌ No session data found","error"),updateLog("crosspage","Cross-page persistence may not be working","warning")}catch(e){updateLog("crosspage",`❌ Restore failed: ${e.message}`,"error")}}window.addEventListener("load",(()=>{const e=sessionStorage.getItem("va_active_session"),s=localStorage.getItem("va_test_session_backup");if((e||s)&&(updateLog("crosspage","🔄 Page loaded - session data available","info"),e)){updateLog("crosspage",`Found session: ${JSON.parse(e).sessionId}`,"info")}}))</script></body></html>