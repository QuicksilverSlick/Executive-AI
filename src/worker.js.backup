/*
 * DREAMFORGE HIVE-MIND CHAIN OF CUSTODY
 *
 * @file-purpose: Cloudflare Workers entry point for Executive AI Training voice agent application
 * @version: 1.0.0
 * @init-author: developer-agent
 * @init-cc-sessionId: cc-unknown-20250815-296
 * @init-timestamp: 2025-08-15T17:30:00Z
 * @reasoning:
 * - **Objective:** Create Workers entry point that handles API routes and delegates to ASSETS for static files
 * - **Strategy:** Route API calls through Worker logic and serve static assets through Assets binding
 * - **Outcome:** Proper Workers deployment with optimized routing and error handling
 */

// Import the Astro app handler
import { app } from '../dist/_worker.js/index.js';

/**
 * CORS headers for the voice agent API
 */
const CORS_HEADERS = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
  'Access-Control-Allow-Headers': 'Content-Type, Authorization, X-Requested-With',
  'Access-Control-Max-Age': '86400'
};

/**
 * Security headers for production deployment
 */
const SECURITY_HEADERS = {
  'X-Content-Type-Options': 'nosniff',
  'X-Frame-Options': 'DENY',
  'X-XSS-Protection': '1; mode=block',
  'Referrer-Policy': 'strict-origin-when-cross-origin',
  'Content-Security-Policy': "default-src 'self'; script-src 'self' 'unsafe-eval' 'unsafe-inline'; style-src 'self' 'unsafe-inline'; img-src 'self' data: https:; connect-src 'self' https://api.openai.com wss://api.openai.com; media-src 'self' data: blob:; worker-src 'self' blob:;"
};

/**
 * Rate limiting configuration
 */
const RATE_LIMIT_CONFIG = {
  windowMs: 60 * 1000, // 1 minute
  maxRequests: 10, // per window
  apiMaxRequests: 50 // Higher limit for API endpoints
};

/**
 * Rate limiting function using KV storage
 */
async function rateLimit(request, env, isApiRoute = false) {
  const clientIP = request.headers.get('CF-Connecting-IP') || 'unknown';
  const key = `rate_limit:${clientIP}`;
  const now = Date.now();
  const window = RATE_LIMIT_CONFIG.windowMs;
  const maxRequests = isApiRoute ? RATE_LIMIT_CONFIG.apiMaxRequests : RATE_LIMIT_CONFIG.maxRequests;

  try {
    // Get current rate limit data
    const existing = await env.RATE_LIMITS.get(key);
    let requests = existing ? JSON.parse(existing) : { count: 0, resetTime: now + window };

    // Reset if window has expired
    if (now > requests.resetTime) {
      requests = { count: 0, resetTime: now + window };
    }

    // Check if limit exceeded
    if (requests.count >= maxRequests) {
      return new Response('Too Many Requests', {
        status: 429,
        headers: {
          ...CORS_HEADERS,
          'Retry-After': Math.ceil((requests.resetTime - now) / 1000).toString()
        }
      });
    }

    // Increment counter
    requests.count++;
    await env.RATE_LIMITS.put(key, JSON.stringify(requests), {
      expirationTtl: Math.ceil(window / 1000)
    });

    return null; // No rate limit hit
  } catch (error) {
    console.error('Rate limiting error:', error);
    // Continue without rate limiting on error
    return null;
  }
}

/**
 * Handle API routes through the Worker
 */
async function handleApiRoute(request, env, ctx) {
  const url = new URL(request.url);
  
  // Apply rate limiting for API routes
  const rateLimitResponse = await rateLimit(request, env, true);
  if (rateLimitResponse) {
    return rateLimitResponse;
  }

  try {
    // Forward to Astro app handler
    const response = await app.fetch(request, env, ctx);
    
    // Add CORS and security headers to API responses
    const headers = new Headers(response.headers);
    Object.entries(CORS_HEADERS).forEach(([key, value]) => {
      headers.set(key, value);
    });
    
    return new Response(response.body, {
      status: response.status,
      statusText: response.statusText,
      headers
    });
  } catch (error) {
    console.error('API route error:', error);
    
    return new Response(JSON.stringify({
      error: 'Internal Server Error',
      message: 'An error occurred processing your request'
    }), {
      status: 500,
      headers: {
        'Content-Type': 'application/json',
        ...CORS_HEADERS
      }
    });
  }
}

/**
 * Handle static assets through the ASSETS binding
 */
async function handleStaticAsset(request, env) {
  try {
    // Try to serve from static assets
    const response = await env.ASSETS.fetch(request);
    
    if (response.status === 404) {
      // For SPA, serve index.html for non-API routes
      const url = new URL(request.url);
      if (!url.pathname.startsWith('/api/') && !url.pathname.includes('.')) {
        const indexRequest = new Request(new URL('/', request.url), request);
        const indexResponse = await env.ASSETS.fetch(indexRequest);
        
        if (indexResponse.ok) {
          const headers = new Headers(indexResponse.headers);
          Object.entries(SECURITY_HEADERS).forEach(([key, value]) => {
            headers.set(key, value);
          });
          
          return new Response(indexResponse.body, {
            status: 200,
            statusText: 'OK',
            headers
          });
        }
      }
    }
    
    // Add security headers to static assets
    if (response.ok) {
      const headers = new Headers(response.headers);
      Object.entries(SECURITY_HEADERS).forEach(([key, value]) => {
        headers.set(key, value);
      });
      
      return new Response(response.body, {
        status: response.status,
        statusText: response.statusText,
        headers
      });
    }
    
    return response;
  } catch (error) {
    console.error('Static asset error:', error);
    
    return new Response('Not Found', {
      status: 404,
      headers: CORS_HEADERS
    });
  }
}

/**
 * Main Worker fetch handler
 */
export default {
  async fetch(request, env, ctx) {
    const url = new URL(request.url);
    
    // Handle CORS preflight requests
    if (request.method === 'OPTIONS') {
      return new Response(null, {
        status: 204,
        headers: CORS_HEADERS
      });
    }
    
    // Route API requests to Worker
    if (url.pathname.startsWith('/api/')) {
      return handleApiRoute(request, env, ctx);
    }
    
    // Apply general rate limiting for non-API routes
    const rateLimitResponse = await rateLimit(request, env, false);
    if (rateLimitResponse) {
      return rateLimitResponse;
    }
    
    // Route static assets to ASSETS binding
    return handleStaticAsset(request, env);
  }
};

/*
 * DREAMFORGE AUDIT TRAIL
 *
 * ---
 * @revision: 1.0.0
 * @author: developer-agent
 * @cc-sessionId: cc-unknown-20250815-296
 * @timestamp: 2025-08-15T17:30:00Z
 * @reasoning:
 * - **Objective:** Created Workers entry point with proper routing between API calls and static assets
 * - **Strategy:** Implemented rate limiting, CORS handling, security headers, and proper error handling
 * - **Outcome:** Complete Worker that handles voice agent API through Worker and serves static files through Assets binding
 */